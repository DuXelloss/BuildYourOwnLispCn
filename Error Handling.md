# 第零八章 • 错误处理

##异常退出

你可能已经注意到，上一章中写就的程序是存在问题的。试着输入下面的语句，看看会发生什么。

```
Lispy Version 0.0.0.0.3
Press Ctrl+c to Exit

lispy> / 10 0
```
噢！程序竟然崩溃了，因为 0 不能作为被除数。在开发过程中，程序崩溃是很正常的。但最终的产品我们则希望其永远不要崩溃，并且告诉用户错误出在哪里。

目前，我们的程序仅能打印出语法上的错误，但对于表达式求值过程中产生的错误却无能为力。C 语言并不擅长错误处理，但这也是不可避免的。随着系统复杂度的提升，后期再开始做的话难度就更大了。

C 程序的“崩溃传统”历史悠久。任何程序出了错，操作系统只管将其内存回收。程序崩溃的原因和方式也千奇百怪。但是 C 程序并非有魔法驱动的，如果你的程序运行出了错，与其坐在屏幕前“望眼欲穿”，不如借此机会学习一下调试工具 `gdb` 和 `valgrind` 的用法。学会使用这些强大的工具，会让你事半功倍。

##Lisp Value

C 语言有很多种错误处理方式，但针对当前的项目，我更加倾向于使错误也成为表达式求值的结果。也就是说，在 Lispy 中，表达式求值的结果要么是*数字*，要么便是*错误*。举例说，表达式 `+ 1 2` 求值会得到数字 `3`，而表达式 `/ 10 0` 求值则会得到一个错误。

为了达到这个目的，我们需要能表示这两种结果的数据结构。简单起见，我们使用结构体来表示，并使用 `type` 字段来告诉我们当前哪个字段是有意义的。

结构体的名为 `lval`，取义 *Lisp Value*，定义如下：

```
/* Declare New lval Struct */
typedef struct {
  int type;
  long num;
  int err;
} lval;
```